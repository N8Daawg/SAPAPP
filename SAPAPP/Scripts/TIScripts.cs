using SAPAPP.Configs;
using System;
using System.ComponentModel;
using System.Diagnostics;
using System.IO;
using System.IO.Ports;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Shapes;
using static System.Net.WebRequestMethods;



namespace SAPAPP.Scripts
{
    internal class TIScript(TextBlock fd, TextBlock pp, ProgressBar pb) : Script(fd, pp, pb)
    {
        private const int BaudRate = 115200;

        private const int WRITE_MAX = 30;

        public override void Download(Part download)
        {
            if (!backgroundWorker.IsBusy)
            {
                currentDownload = download;
                backgroundWorker.RunWorkerAsync();
            }
        }

        protected override void BackgroundWorker_DoWork(object sender, DoWorkEventArgs e)
        {
            BackgroundWorker worker = sender as BackgroundWorker;

            string InputFile = currentDownload.FirmwarePath + "\\" +  currentDownload.Executable;
            string OutputFile = currentDownload.FirmwarePath + "\\" + "data.h";


            StreamWriter sw = new(OutputFile);
            StreamReader sr = new(InputFile);
            string[] file = sr.ReadToEnd().Split("\n");

            string lines = "\n/* Autogenerated by FuelGaugeProgrammer.py */\n\n" +
             "#ifndef DATA_H\n" +
             "#define DATA_H\n\n" +
             "// This is data to be written to the device.\n" +
             "#ifndef DATA_ARRAY\n" +
             "#define DATA_ARRAY\n" +
             "const uint8_t data[] =\n" +
             "{//          cmd  addr  len   data\n";
            sw.Write(lines);

            foreach (string full in file)
            {
                string line = full.Trim();
                if (line.Length > 0)
                {
                    if (line[0] == ';')
                    {
                        continue;
                    }
                    else
                    {
                        string[] LineItems = line.Split(' ');
                        string command = LineItems[0];

                        switch (command)
                        {
                            case "X:":            // Process the delay command "X".
                                {
                                    // Print the command.
                                    sw.Write("\t(uint8_t)\'X\',");

                                    // Find the number of milliseconds to delay.
                                    var delay = LineItems[1];
                                    var by = short.Parse(delay);
                                    // Split the delay into two bytes
                                    var highByte = (byte)((by >> 8) & 0xFF);    //highByte = (int(delay) >> 8) & 0xFF;
                                    var lowByte = (byte)(by & 0xFF);            //lowByte = int(delay) & 0xFF

                                    // Print both bytes as hexadecimal numbers.
                                    sw.Write(string.Format(" 0x{0:X2}, 0x{1:X2},", highByte, lowByte));
                                    sw.Write(string.Format("\t// {0:S} ms delay\n", delay));
                                    break;
                                };
                            case "C:":            // Process the compare command "C".
                                {
                                    // Print the command.
                                    sw.Write("\t(uint8_t)\'C\',");

                                    // Find the address.
                                    string address = LineItems[1];

                                    // Print the address.
                                    sw.Write(" 0x" + address + ",");

                                    // Form list of the remaining items.
                                    string[] dataItems = [.. LineItems.Skip(2)];

                                    // Print the number of data items as a hexadecimal number.
                                    sw.Write(string.Format(" 0x{0:X2},", dataItems.Length));

                                    // Print the data items.
                                    foreach (string eachItem in dataItems)
                                    {
                                        sw.Write(" 0x" + eachItem + ',');
                                    }

                                    // Print a newline.
                                    sw.WriteLine();
                                    break;
                                };
                            case "W:":            // Process the write command "W".
                                {
                                    // Find the address.
                                    string address = LineItems[1];

                                    // Form list of the remaining items.
                                    string[] dataItems = [.. LineItems.Skip(2)];

                                    // Find the number of ata items.
                                    int length = dataItems.Length;

                                    // Remember out current position in the dataItems list.
                                    int index = 0;

                                    // Process all data items.
                                    while (length > 0)
                                    {
                                        // Print the command
                                        sw.Write("\t(uint8_t)\'W\',");

                                        // Print the address
                                        sw.Write(" 0x" + address + ',');


                                        // Split into commands of no more than 30 bytes.
                                        if (length > WRITE_MAX)
                                        {
                                            //Print 30 (the number of data items = WRITE_MAX).
                                            sw.Write(string.Format(" 0x{0:X2},", WRITE_MAX));

                                            // Print the index, but not for the first packet,
                                            // because it's already there (see note at top of file).
                                            // If we aren't on the first chunk of 30...
                                            if (index == 0)
                                            {
                                                // Print the flash index, which is the first data item.
                                                sw.Write(" 0x" + dataItems[0] + ',');


                                                // Delete the flash index from the dataItems list.
                                                dataItems = [.. dataItems.Skip(1)];
                                            }
                                            else
                                            {
                                                // Print the flash index, which we calculated
                                                sw.Write(string.Format(" 0x{0:X2},", index));

                                            }

                                            // Print 29 data items (29 = WRITE_MAX - 1).
                                            foreach (string eachItem in dataItems.Skip(index).Take(WRITE_MAX - 1))
                                            {
                                                sw.Write(" 0x" + eachItem + ',');
                                            }

                                            //subtract 29 from length (29 = WRITE_MAX - 1).
                                            length -= WRITE_MAX - 1;

                                            // Add 29 to index (29 = WRITE_MAX).
                                            index += WRITE_MAX - 1;
                                        }
                                        else
                                        {
                                            //Print the number of data items as a hexadecimal number.
                                            sw.Write(string.Format(" 0x{0:X2},", length));


                                            // Print the flash index, but not for the first packet,
                                            // because it's already there (see note at top of file).
                                            // If we aren't on the first chunk of 30...
                                            if (index != 0)
                                            {
                                                // Print the flash index.
                                                sw.Write(string.Format(" 0x{0:X2},", index));
                                            }

                                            //Print the data items
                                            foreach (string eachItem in dataItems.Skip(index))
                                            {
                                                sw.Write(" 0x" + eachItem + ',');
                                            }

                                            // Update length.
                                            length = 0;
                                        }

                                        //Print a newline.
                                        sw.WriteLine();
                                    }
                                    break;
                                };
                            default:
                                {
                                    HandleError("ERROR:  Unexpected command: " + command);
                                    break;
                                };
                        }
                    }
                }
            }
            // Add stuff to the end of the h file.
            lines = "};\n" +
                    "#else\n" +
                    "extern uint8_t data[];\n" +
                    "#endif\t// DATA_ARRAY\n\n" +
                    "#endif\t// DATA_H";
            sw.Write(lines);


            // close the input and output files
            sw.Close();
            sr.Close();

            MessageBox.Show(OutputFile);
        }

        protected override void HandleError(string line)
        {
            Cancel();
        }

        protected override void UpdateProgress(string line)
        {
            throw new NotImplementedException();
        }
    }
}